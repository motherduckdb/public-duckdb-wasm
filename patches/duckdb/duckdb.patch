diff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp
index ec11c12890..3471cdb13f 100644
--- a/src/execution/expression_executor.cpp
+++ b/src/execution/expression_executor.cpp
@@ -290,7 +290,7 @@ idx_t ExpressionExecutor::Select(const Expression &expr, ExpressionState *state,
 	D_ASSERT(true_sel || false_sel);
 	D_ASSERT(expr.return_type.id() == LogicalTypeId::BOOLEAN);
 	switch (expr.GetExpressionClass()) {
-#ifndef DUCKDB_SMALLER_BINARY
+#ifndef DUCKDB_SMALLER_BINARY_NO_SELECT
 	case ExpressionClass::BOUND_BETWEEN:
 		return Select(expr.Cast<BoundBetweenExpression>(), state, sel, count, true_sel, false_sel);
 #endif
diff --git a/src/execution/expression_executor/execute_between.cpp b/src/execution/expression_executor/execute_between.cpp
index 3418351362..52cf454530 100644
--- a/src/execution/expression_executor/execute_between.cpp
+++ b/src/execution/expression_executor/execute_between.cpp
@@ -7,7 +7,7 @@
 
 namespace duckdb {
 
-#ifndef DUCKDB_SMALLER_BINARY
+#ifndef DUCKDB_SMALLER_BINARY_NO_SELECT
 struct BothInclusiveBetweenOperator {
 	template <class T>
 	static inline bool Operation(T input, T lower, T upper) {
@@ -133,8 +133,8 @@ void ExpressionExecutor::Execute(const BoundBetweenExpression &expr, ExpressionS
 
 idx_t ExpressionExecutor::Select(const BoundBetweenExpression &expr, ExpressionState *state, const SelectionVector *sel,
                                  idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
-#ifdef DUCKDB_SMALLER_BINARY
-	throw InternalException("ExpressionExecutor::Select not available with DUCKDB_SMALLER_BINARY");
+#ifdef DUCKDB_SMALLER_BINARY_NO_SELECT
+	throw InternalException("ExpressionExecutor::Select not available with DUCKDB_SMALLER_BINARY_NO_SELECT");
 #else
 	// resolve the children
 	Vector input(state->intermediate_chunk.data[0]);
diff --git a/src/function/cast/enum_casts.cpp b/src/function/cast/enum_casts.cpp
index fcf764baac..47d3abe925 100644
--- a/src/function/cast/enum_casts.cpp
+++ b/src/function/cast/enum_casts.cpp
@@ -17,8 +17,9 @@ static bool EnumEnumCast(Vector &source, Vector &result, idx_t count, CastParame
 		    auto key = EnumType::GetPos(res_enum_type, dictionary_data[value]);
 		    if (key == -1) {
 			    if (!parameters.error_message) {
-				    return HandleVectorCastError::Operation<RES_TYPE>(CastExceptionText<SRC_TYPE, RES_TYPE>(value),
-				                                                      mask, row_idx, vector_cast_data);
+				    return HandleVectorCastError::Operation<RES_TYPE>(
+				        CastExceptionText<SRC_TYPE>(value, TypeIdInfo::CreateObject<RES_TYPE>), mask, row_idx,
+				        vector_cast_data);
 			    } else {
 				    mask.SetInvalid(row_idx);
 			    }
diff --git a/src/function/cast/string_cast.cpp b/src/function/cast/string_cast.cpp
index 511d09a861..ab4e1395ab 100644
--- a/src/function/cast/string_cast.cpp
+++ b/src/function/cast/string_cast.cpp
@@ -21,8 +21,10 @@ static bool StringEnumCastLoop(const string_t *source_data, ValidityMask &source
 		if (source_mask.RowIsValid(source_idx)) {
 			auto pos = EnumType::GetPos(result_type, source_data[source_idx]);
 			if (pos == -1) {
+
 				result_data[i] = HandleVectorCastError::Operation<T>(
-				    CastExceptionText<string_t, T>(source_data[source_idx]), result_mask, i, vector_cast_data);
+				    CastExceptionText<string_t>(source_data[source_idx], TypeIdInfo::CreateObject<T>), result_mask, i,
+				    vector_cast_data);
 			} else {
 				result_data[i] = UnsafeNumericCast<T>(pos);
 			}
diff --git a/src/function/table/system/duckdb_extensions.cpp b/src/function/table/system/duckdb_extensions.cpp
index 6a528c111a..8ba2511a20 100644
--- a/src/function/table/system/duckdb_extensions.cpp
+++ b/src/function/table/system/duckdb_extensions.cpp
@@ -99,7 +99,7 @@ unique_ptr<GlobalTableFunctionState> DuckDBExtensionsInit(ClientContext &context
 #ifndef WASM_LOADABLE_EXTENSIONS
 	auto ext_directory = ExtensionHelper::GetExtensionDirectoryPath(context);
 	fs.ListFiles(ext_directory, [&](const string &path, bool is_directory) {
-		if (!StringUtil::EndsWith(path, ".duckdb_extension")) {
+		if (!StringUtil::EndsWith(path, ".duckdb_extension.wasm")) {
 			return;
 		}
 		ExtensionInformation info;
diff --git a/src/include/duckdb/common/operator/cast_operators.hpp b/src/include/duckdb/common/operator/cast_operators.hpp
index ac55e5a69d..e469ca2b11 100644
--- a/src/include/duckdb/common/operator/cast_operators.hpp
+++ b/src/include/duckdb/common/operator/cast_operators.hpp
@@ -53,19 +53,31 @@ struct TryCastErrorMessageCommaSeparated {
 	}
 };
 
-template <class SRC, class DST>
-static string CastExceptionText(SRC input) {
+struct TypeIdInfo {
+	explicit TypeIdInfo(string name, bool isNum) : name(name), isNum(isNum) {
+	}
+	template <typename TYPE>
+	__attribute__((noinline)) static TypeIdInfo CreateObject() {
+		return TypeIdInfo(TypeIdToString(GetTypeId<TYPE>()), TypeIsNumber<TYPE>());
+	}
+	string name;
+	bool isNum;
+};
+
+typedef TypeIdInfo (*callback_typeidinfo)(void);
+
+template <class SRC>
+static string CastExceptionText(SRC input, callback_typeidinfo func) {
+	auto info = func();
 	if (std::is_same<SRC, string_t>()) {
-		return "Could not convert string '" + ConvertToString::Operation<SRC>(input) + "' to " +
-		       TypeIdToString(GetTypeId<DST>());
+		return "Could not convert string '" + ConvertToString::Operation<SRC>(input) + "' to " + info.name;
 	}
-	if (TypeIsNumber<SRC>() && TypeIsNumber<DST>()) {
+	if (TypeIsNumber<SRC>() && info.isNum) {
 		return "Type " + TypeIdToString(GetTypeId<SRC>()) + " with value " + ConvertToString::Operation<SRC>(input) +
-		       " can't be cast because the value is out of range for the destination type " +
-		       TypeIdToString(GetTypeId<DST>());
+		       " can't be cast because the value is out of range for the destination type " + info.name;
 	}
 	return "Type " + TypeIdToString(GetTypeId<SRC>()) + " with value " + ConvertToString::Operation<SRC>(input) +
-	       " can't be cast to the destination type " + TypeIdToString(GetTypeId<DST>());
+	       " can't be cast to the destination type " + info.name;
 }
 
 struct Cast {
@@ -73,7 +85,7 @@ struct Cast {
 	static inline DST Operation(SRC input) {
 		DST result;
 		if (!TryCast::Operation(input, result)) {
-			throw InvalidInputException(CastExceptionText<SRC, DST>(input));
+			throw InvalidInputException(CastExceptionText<SRC>(input, TypeIdInfo::CreateObject<DST>));
 		}
 		return result;
 	}
diff --git a/src/include/duckdb/function/cast/vector_cast_helpers.hpp b/src/include/duckdb/function/cast/vector_cast_helpers.hpp
index 1c50c34140..eea11564d0 100644
--- a/src/include/duckdb/function/cast/vector_cast_helpers.hpp
+++ b/src/include/duckdb/function/cast/vector_cast_helpers.hpp
@@ -36,8 +36,8 @@ struct VectorTryCastOperator {
 			return output;
 		}
 		auto data = reinterpret_cast<VectorTryCastData *>(dataptr);
-		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
-		                                                     idx, *data);
+		return HandleVectorCastError::Operation<RESULT_TYPE>(
+		    CastExceptionText<INPUT_TYPE>(input, TypeIdInfo::CreateObject<RESULT_TYPE>), mask, idx, *data);
 	}
 };
 
@@ -50,8 +50,9 @@ struct VectorTryCastStrictOperator {
 		if (DUCKDB_LIKELY(OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output, data->parameters.strict))) {
 			return output;
 		}
-		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
-		                                                     idx, *data);
+
+		return HandleVectorCastError::Operation<RESULT_TYPE>(
+		    CastExceptionText<INPUT_TYPE>(input, TypeIdInfo::CreateObject<RESULT_TYPE>), mask, idx, *data);
 	}
 };
 
@@ -66,8 +67,9 @@ struct VectorTryCastErrorOperator {
 		}
 		bool has_error = data->parameters.error_message && !data->parameters.error_message->empty();
 		return HandleVectorCastError::Operation<RESULT_TYPE>(
-		    has_error ? *data->parameters.error_message : CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask, idx,
-		    *data);
+		    has_error ? *data->parameters.error_message
+		              : CastExceptionText<INPUT_TYPE>(input, TypeIdInfo::CreateObject<RESULT_TYPE>),
+		    mask, idx, *data);
 	}
 };
 
@@ -81,8 +83,8 @@ struct VectorTryCastStringOperator {
 		        OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output, data->result, data->parameters))) {
 			return output;
 		}
-		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
-		                                                     idx, *data);
+		return HandleVectorCastError::Operation<RESULT_TYPE>(
+		    CastExceptionText<INPUT_TYPE>(input, TypeIdInfo::CreateObject<RESULT_TYPE>), mask, idx, *data);
 	}
 };
 
diff --git a/src/include/duckdb/main/database.hpp b/src/include/duckdb/main/database.hpp
index 7e43de6005..094ee08815 100644
--- a/src/include/duckdb/main/database.hpp
+++ b/src/include/duckdb/main/database.hpp
@@ -17,6 +17,9 @@
 #include "duckdb/main/extension_manager.hpp"
 
 namespace duckdb {
+
+extern bool preloaded_httpfs;
+
 class BufferManager;
 class DatabaseManager;
 class StorageManager;
@@ -94,6 +97,11 @@ private:
 	unique_ptr<ExternalFileCache> external_file_cache;
 
 	duckdb_ext_api_v1 (*create_api_v1)();
+
+public:
+       static void SetPreferredRepository(const string& extension, const string &repository);
+       static string GetPreferredRepository(const string& extension);
+       static unordered_map<string, string> extensionsRepos;
 };
 
 //! The database object. This object holds the catalog and all the
diff --git a/src/include/duckdb/main/extension_install_info.hpp b/src/include/duckdb/main/extension_install_info.hpp
index 6ccd1a1156..8040f537b6 100644
--- a/src/include/duckdb/main/extension_install_info.hpp
+++ b/src/include/duckdb/main/extension_install_info.hpp
@@ -55,9 +55,9 @@ public:
 
 struct ExtensionRepository {
 	//! All currently available repositories
-	static constexpr const char *CORE_REPOSITORY_URL = "http://extensions.duckdb.org";
-	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "http://nightly-extensions.duckdb.org";
-	static constexpr const char *COMMUNITY_REPOSITORY_URL = "http://community-extensions.duckdb.org";
+	static constexpr const char *CORE_REPOSITORY_URL = "https://extensions.duckdb.org";
+	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "https://nightly-extensions.duckdb.org";
+	static constexpr const char *COMMUNITY_REPOSITORY_URL = "https://community-extensions.duckdb.org";
 
 	//! Debugging repositories (target local, relative paths that are produced by DuckDB's build system)
 	static constexpr const char *BUILD_DEBUG_REPOSITORY_PATH = "./build/debug/repository";
diff --git a/src/main/config.cpp b/src/main/config.cpp
index d47418109f..0007c502bd 100644
--- a/src/main/config.cpp
+++ b/src/main/config.cpp
@@ -359,7 +359,7 @@ LogicalType DBConfig::ParseLogicalType(const string &type) {
 	if (StringUtil::EndsWith(type, "]")) {
 		// array - recurse
 		auto bracket_open_idx = type.rfind('[');
-		if (bracket_open_idx == DConstants::INVALID_INDEX || bracket_open_idx == 0) {
+		if (bracket_open_idx == string::npos || bracket_open_idx == 0) {
 			throw InternalException("Ill formatted type: '%s'", type);
 		}
 		idx_t array_size = 0;
diff --git a/src/main/database.cpp b/src/main/database.cpp
index 8d23656aab..72df3bba7d 100644
--- a/src/main/database.cpp
+++ b/src/main/database.cpp
@@ -1,5 +1,4 @@
 #include "duckdb/main/database.hpp"
-
 #include "duckdb/catalog/catalog.hpp"
 #include "duckdb/common/virtual_file_system.hpp"
 #include "duckdb/execution/index/index_type_set.hpp"
@@ -37,6 +36,7 @@
 #include "duckdb/common/thread.hpp"
 #endif
 
+
 namespace duckdb {
 
 DBConfig::DBConfig() {
@@ -344,6 +344,28 @@ DuckDB::DuckDB(DatabaseInstance &instance_p) : instance(instance_p.shared_from_t
 DuckDB::~DuckDB() {
 }
 
+unordered_map<string, string> DatabaseInstance::extensionsRepos = {};
+
+void DatabaseInstance::SetPreferredRepository(const string& extension, const string &repository) {
+	auto &x = extensionsRepos;
+	auto it = x.find(extension);
+	if (it != x.end()) {
+		it->second=repository;
+	} else {
+		x.emplace(extension, repository);
+	}
+}
+
+string DatabaseInstance::GetPreferredRepository(const string& extension) {
+	const auto &x = extensionsRepos;
+	auto it = x.find(extension);
+	if (it != x.end()) {
+		return it->second;
+	}
+	return "";
+}
+
+
 SecretManager &DatabaseInstance::GetSecretManager() {
 	return *config.secret_manager;
 }
@@ -494,6 +516,10 @@ idx_t DuckDB::NumberOfThreads() {
 }
 
 bool DatabaseInstance::ExtensionIsLoaded(const string &name) {
+ 	auto extension_name = ExtensionHelper::GetExtensionName(name);
+	if (extension_name == "httpfs" && preloaded_httpfs) {
+		return true;
+	}
 	return extension_manager->ExtensionIsLoaded(name);
 }
 
diff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp
index 74add5379a..57871bbc4a 100644
--- a/src/main/extension/extension_helper.cpp
+++ b/src/main/extension/extension_helper.cpp
@@ -336,13 +336,12 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(ClientContext &c
 	vector<ExtensionUpdateResult> result;
 	DatabaseInstance &db = DatabaseInstance::GetDatabase(context);
 
-#ifndef WASM_LOADABLE_EXTENSIONS
 	case_insensitive_set_t seen_extensions;
 
 	// scan the install directory for installed extensions
 	auto ext_directory = ExtensionHelper::ExtensionDirectory(db, fs);
 	fs.ListFiles(ext_directory, [&](const string &path, bool is_directory) {
-		if (!StringUtil::EndsWith(path, ".duckdb_extension")) {
+		if (!StringUtil::EndsWith(path, ".duckdb_extension.wasm")) {
 			return;
 		}
 
@@ -353,7 +352,6 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(ClientContext &c
 
 		result.push_back(UpdateExtensionInternal(context, db, fs, fs.JoinPath(ext_directory, path), extension_name));
 	});
-#endif
 
 	return result;
 }
@@ -363,7 +361,7 @@ ExtensionUpdateResult ExtensionHelper::UpdateExtension(ClientContext &context, c
 	DatabaseInstance &db = DatabaseInstance::GetDatabase(context);
 	auto ext_directory = ExtensionHelper::ExtensionDirectory(db, fs);
 
-	auto full_extension_path = fs.JoinPath(ext_directory, extension_name + ".duckdb_extension");
+	auto full_extension_path = fs.JoinPath(ext_directory, extension_name + ".duckdb_extension.wasm");
 
 	auto update_result = UpdateExtensionInternal(context, db, fs, full_extension_path, extension_name);
 
@@ -436,7 +434,7 @@ ExtensionLoadResult ExtensionHelper::LoadExtensionInternal(DuckDB &db, const std
 	if (!initial_load && StringUtil::Contains(DUCKDB_EXTENSIONS_TEST_WITH_LOADABLE, "," + extension + ",")) {
 		Connection con(db);
 		auto result = con.Query((string) "LOAD '" + DUCKDB_EXTENSIONS_BUILD_PATH + "/" + extension + "/" + extension +
-		                        ".duckdb_extension'");
+		                        ".duckdb_extension.wasm'");
 		if (result->HasError()) {
 			result->Print();
 			return ExtensionLoadResult::EXTENSION_UNKNOWN;
diff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp
index d0996d952b..4f82055911 100644
--- a/src/main/extension/extension_install.cpp
+++ b/src/main/extension/extension_install.cpp
@@ -145,6 +145,9 @@ bool ExtensionHelper::CreateSuggestions(const string &extension_name, string &me
 unique_ptr<ExtensionInstallInfo> ExtensionHelper::InstallExtension(DatabaseInstance &db, FileSystem &fs,
                                                                    const string &extension,
                                                                    ExtensionInstallOptions &options) {
+	if (options.repository) {
+		DatabaseInstance::SetPreferredRepository(extension, options.repository->path);
+	}
 #ifdef WASM_LOADABLE_EXTENSIONS
 	// Install is currently a no-op
 	return nullptr;
@@ -155,6 +158,9 @@ unique_ptr<ExtensionInstallInfo> ExtensionHelper::InstallExtension(DatabaseInsta
 
 unique_ptr<ExtensionInstallInfo> ExtensionHelper::InstallExtension(ClientContext &context, const string &extension,
                                                                    ExtensionInstallOptions &options) {
+	if (options.repository) {
+		DatabaseInstance::SetPreferredRepository(extension, options.repository->path);
+	}
 #ifdef WASM_LOADABLE_EXTENSIONS
 	// Install is currently a no-op
 	return nullptr;
@@ -187,7 +193,7 @@ static void WriteExtensionFileToDisk(QueryContext &query_context, FileSystem &fs
 
 	// Now signature has been checked (if signature checking is enabled)
 
-	// Open target_file, at this points ending with '.duckdb_extension'
+	// Open target_file, at this points ending with '.duckdb_extension.wasm'
 	auto target_file =
 	    fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_READ | FileFlags::FILE_FLAGS_APPEND |
 	                          FileFlags::FILE_FLAGS_FILE_CREATE_NEW | FileFlags::FILE_FLAGS_ENABLE_EXTENSION_INSTALL);
@@ -256,15 +262,15 @@ static void WriteExtensionFiles(QueryContext &query_context, FileSystem &fs, con
                                 const string &local_extension_path, void *in_buffer, idx_t file_size,
                                 ExtensionInstallInfo &info, DBConfig &config) {
 	// temp_path ends with '.duckdb_extension'
-	if (!StringUtil::EndsWith(temp_path, ".duckdb_extension")) {
+	if (!StringUtil::EndsWith(temp_path, ".duckdb_extension.wasm")) {
 		throw InternalException("Extension install temp_path of '%s' is not valid, should end in '.duckdb_extension'",
 		                        temp_path);
 	}
-	// local_extension_path ends with '.duckdb_extension', and given it will be written only after signature checks,
+	// local_extension_path ends with '.duckdb_extension.wasm', and given it will be written only after signature checks,
 	// it's now loadable
-	if (!StringUtil::EndsWith(local_extension_path, ".duckdb_extension")) {
+	if (!StringUtil::EndsWith(local_extension_path, ".duckdb_extension.wasm")) {
 		throw InternalException("Extension install local_extension_path of '%s' is not valid, should end in "
-		                        "'.duckdb_extension'",
+		                        "'.duckdb_extension.wasm'",
 		                        temp_path);
 	}
 
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index 4f7f7d2b28..0c28ad3a4e 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -11,6 +11,8 @@
 #include "duckdb/main/settings.hpp"
 #include "mbedtls_wrapper.hpp"
 
+
+#include <iostream>
 #ifndef DUCKDB_NO_THREADS
 #include <thread>
 #endif // DUCKDB_NO_THREADS
@@ -371,13 +373,29 @@ bool ExtensionHelper::TryInitialLoad(DatabaseInstance &db, FileSystem &fs, const
 	auto filename = fs.ConvertSeparators(extension);
 
 	bool direct_load;
+	ParsedExtensionMetaData parsed_metadata;
+	ExtensionInstallMode install_mode = ExtensionInstallMode::UNKNOWN;
 
 	// shorthand case
 	if (!ExtensionHelper::IsFullPath(extension)) {
 		direct_load = false;
 		string extension_name = ApplyExtensionAlias(extension);
 #ifdef WASM_LOADABLE_EXTENSIONS
-		string url_template = ExtensionUrlTemplate(&config, "");
+		ExtensionRepository repository;
+
+		string custom_endpoint = db.config.options.custom_extension_repo;
+		if (!custom_endpoint.empty()) {
+			repository = ExtensionRepository("custom", custom_endpoint);
+		}
+               {
+                       auto preferredRepo = DatabaseInstance::GetPreferredRepository(extension);
+                       if (!preferredRepo.empty()) {
+                               repository = ExtensionRepository("x", preferredRepo);
+                       }
+               }
+		install_mode = ExtensionInstallMode::REPOSITORY;
+
+		string url_template = ExtensionUrlTemplate(db, repository, "");
 		string url = ExtensionFinalizeUrlTemplate(url_template, extension_name);
 
 		char *str = (char *)EM_ASM_PTR(
@@ -418,41 +436,32 @@ bool ExtensionHelper::TryInitialLoad(DatabaseInstance &db, FileSystem &fs, const
 		direct_load = true;
 		filename = fs.ExpandPath(filename);
 	}
-	if (!StringUtil::EndsWith(filename, ".duckdb_extension")) {
-		throw PermissionException(
-		    "DuckDB extensions are files ending with '.duckdb_extension', loading different "
-		    "files is not possible, error while loading from '%s', consider 'INSTALL <path>; LOAD <name>;'",
-		    filename);
-	}
-	if (!fs.FileExists(filename)) {
-		string message;
-		bool exact_match = ExtensionHelper::CreateSuggestions(extension, message);
-		if (exact_match) {
-			message += "\nInstall it first using \"INSTALL " + extension + "\".";
-		}
-		error = StringUtil::Format("Extension \"%s\" not found.\n%s", filename, message);
-		return false;
-	}
+	/*	if (!fs.FileExists(filename)) {
+	        string message;
+	        bool exact_match = ExtensionHelper::CreateSuggestions(extension, message);
+	        if (exact_match) {
+	            message += "\nInstall it first using \"INSTALL " + extension + "\".";
+	        }
+	        error = StringUtil::Format("Extension \"%s\" not found.\n%s", filename, message);
+	        return false;
+	    }
+	*/
 
-	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
+	/*	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
 
-	// Parse the extension metadata from the extension binary
-	auto parsed_metadata = ParseExtensionMetaData(*handle);
+	    // Parse the extension metadata from the extension binary
 
-	auto metadata_mismatch_error = parsed_metadata.GetInvalidMetadataError();
+	    auto parsed_metadata = ParseExtensionMetaData(*handle);
 
-	if (!metadata_mismatch_error.empty()) {
-		metadata_mismatch_error = StringUtil::Format("Failed to load '%s', %s", extension, metadata_mismatch_error);
-	}
+	    auto metadata_mismatch_error = parsed_metadata.GetInvalidMetadataError();
 
-	if (!db.config.options.allow_unsigned_extensions) {
-		bool signature_valid;
-		if (parsed_metadata.AppearsValid()) {
-			signature_valid =
-			    CheckExtensionSignature(*handle, parsed_metadata, db.config.options.allow_community_extensions);
-		} else {
-			signature_valid = false;
-		}
+	    if (!metadata_mismatch_error.empty()) {
+	        metadata_mismatch_error = StringUtil::Format("Failed to load '%s', %s", extension, metadata_mismatch_error);
+	    }
+
+	    if (!db.config.options.allow_unsigned_extensions) {
+	        bool signature_valid =
+	            CheckExtensionSignature(*handle, parsed_metadata, db.config.options.allow_community_extensions);
 
 		if (!metadata_mismatch_error.empty()) {
 			throw InvalidInputException(metadata_mismatch_error);
@@ -469,26 +478,203 @@ bool ExtensionHelper::TryInitialLoad(DatabaseInstance &db, FileSystem &fs, const
 		}
 	}
 
+	        if (!metadata_mismatch_error.empty()) {
+	            // Signed extensions perform the full check
+	            throw InvalidInputException(metadata_mismatch_error);
+	        }
+	    } else if (!db.config.options.allow_extensions_metadata_mismatch) {
+	        if (!metadata_mismatch_error.empty()) {
+	            // Unsigned extensions AND configuration allowing n, loading allowed, mainly for
+	            // debugging purposes
+	            throw InvalidInputException(metadata_mismatch_error);
+	        }
+	    }
+	*/
 	auto filebase = fs.ExtractBaseName(filename);
 
 #ifdef WASM_LOADABLE_EXTENSIONS
-	EM_ASM(
+	auto basename = fs.ExtractBaseName(filename);
+	char *exe = NULL;
+	exe = (char *)EM_ASM_PTR(
 	    {
 		    // Next few lines should argubly in separate JavaScript-land function call
 		    // TODO: move them out / have them configurable
-		    const xhr = new XMLHttpRequest();
-		    xhr.open("GET", UTF8ToString($0), false);
-		    xhr.responseType = "arraybuffer";
-		    xhr.send(null);
-		    var uInt8Array = xhr.response;
-		    WebAssembly.validate(uInt8Array);
-		    console.log('Loading extension ', UTF8ToString($1));
+
+		    var url = (UTF8ToString($0));
+
+		    if (typeof XMLHttpRequest === "undefined") {
+			    const os = require('os');
+			    const path = require('path');
+			    const fs = require('fs');
+
+			    var array = url.split("/");
+			    var l = array.length;
+
+			    var folder = path.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" +
+			                                             array[l - 2] + "/");
+			    var filePath = path.join(folder, array[l - 1]);
+
+			    try {
+				    if (!fs.existsSync(folder)) {
+					    fs.mkdirSync(folder, {recursive : true});
+				    }
+
+				    if (!fs.existsSync(filePath)) {
+					    const int32 = new Int32Array(new SharedArrayBuffer(8));
+					    var Worker = require('node:worker_threads').Worker;
+                var worker = new Worker("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0; async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++; ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
+                    eval: true
+                });
+					    var uInt8Array;
+
+					    int32[0] = 0;
+					    int32[2] = 4;
+					    worker.postMessage(int32);
+
+					    worker.postMessage(url);
+					    Atomics.wait(int32, 0, 0);
+
+					    const int32_2 = new Int32Array(new SharedArrayBuffer(int32[1] + 3 - ((int32[1] + 3) % 4)));
+					    worker.postMessage(int32_2);
+
+					    Atomics.wait(int32, 0, 1);
+
+					    var x = new Uint8Array(int32_2.buffer, 0, int32[1]);
+					    uInt8Array = x;
+					    worker.terminate();
+					    fs.writeFileSync(filePath, uInt8Array);
+
+				    } else {
+					    uInt8Array = fs.readFileSync(filePath);
+				    }
+			    } catch (e) {
+				    console.log("Error fetching module", e);
+				    return 0;
+			    }
+		    } else {
+			    const xhr = new XMLHttpRequest();
+			    xhr.open("GET", url, false);
+			    xhr.responseType = "arraybuffer";
+			    xhr.send(null);
+			    if (xhr.status != 200)
+				    return 0;
+			    uInt8Array = xhr.response;
+		    }
+
+		    var valid = WebAssembly.validate(uInt8Array);
+		    var len = uInt8Array.byteLength;
+		    var fileOnWasmHeap = _malloc(len + 4);
+
+		    var properArray = new Uint8Array(uInt8Array);
+
+		    for (var iii = 0; iii < len; iii++) {
+			    Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
+		    }
+		    var LEN123 = new Uint8Array(4);
+		    LEN123[0] = len % 256;
+		    len -= LEN123[0];
+		    len /= 256;
+		    LEN123[1] = len % 256;
+		    len -= LEN123[1];
+		    len /= 256;
+		    LEN123[2] = len % 256;
+		    len -= LEN123[2];
+		    len /= 256;
+		    LEN123[3] = len % 256;
+		    len -= LEN123[3];
+		    len /= 256;
+		    Module.HEAPU8.set(LEN123, fileOnWasmHeap);
+		    // FIXME: found how to expose those to the logger interface
+		    // console.log(LEN123);
+		    // console.log(properArray);
+		    // console.log(new Uint8Array(Module.HEAPU8, fileOnWasmHeap, len+4));
+		    // console.log('Loading extension ', UTF8ToString($1));
 
 		    // Here we add the uInt8Array to Emscripten's filesystem, for it to be found by dlopen
 		    FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
+		    return fileOnWasmHeap;
 	    },
-	    filename.c_str(), filebase.c_str());
-	auto dopen_from = filebase;
+	    filename.c_str(), basename.c_str());
+	if (!exe) {
+		throw IOException("Extension %s is not available", filename);
+	}
+
+	auto dopen_from = basename;
+	if (!db.config.options.allow_unsigned_extensions) {
+		// signature is the last 256 bytes of the file
+
+		string signature;
+		signature.resize(256);
+
+		D_ASSERT(exe);
+		uint64_t LEN = 0;
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[3];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[2];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[1];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[0];
+		auto signature_offset = LEN - signature.size();
+
+		const idx_t maxLenChunks = 1024ULL * 1024ULL;
+		const idx_t numChunks = (signature_offset + maxLenChunks - 1) / maxLenChunks;
+		std::vector<std::string> hash_chunks(numChunks);
+		std::vector<idx_t> splits(numChunks + 1);
+
+		for (idx_t i = 0; i < numChunks; i++) {
+			splits[i] = maxLenChunks * i;
+		}
+		splits.back() = signature_offset;
+
+		for (idx_t i = 0; i < numChunks; i++) {
+			string x;
+			x.resize(splits[i + 1] - splits[i]);
+			for (idx_t j = 0; j < x.size(); j++) {
+				x[j] = ((uint8_t *)exe)[j + 4 + splits[i]];
+			}
+			ComputeSHA256String(x, &hash_chunks[i]);
+		}
+
+		string hash_concatenation;
+		hash_concatenation.reserve(32 * numChunks); // 256 bits -> 32 bytes per chunk
+
+		for (auto &hash_chunk : hash_chunks) {
+			hash_concatenation += hash_chunk;
+		}
+
+		string two_level_hash;
+		ComputeSHA256String(hash_concatenation, &two_level_hash);
+
+		for (idx_t j = 0; j < signature.size(); j++) {
+			signature[j] = ((uint8_t *)exe)[4 + signature_offset + j];
+		}
+		bool any_valid = false;
+		for (auto &key : ExtensionHelper::GetPublicKeys(db.config.options.allow_community_extensions)) {
+			if (duckdb_mbedtls::MbedTlsWrapper::IsValidSha256Signature(key, signature, two_level_hash)) {
+				any_valid = true;
+				break;
+			}
+		}
+		if (!any_valid) {
+			throw IOException(db.config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));
+		}
+	}
+
+	if (exe) {
+		uint64_t LEN = 0;
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[3];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[2];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[1];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[0];
+		parsed_metadata = ParseExtensionMetaData(exe + LEN + 4 - ParsedExtensionMetaData::FOOTER_SIZE);
+		free(exe);
+	}
 #else
 	auto dopen_from = filename;
 #endif
@@ -505,27 +691,30 @@ bool ExtensionHelper::TryInitialLoad(DatabaseInstance &db, FileSystem &fs, const
 	result.filename = filename;
 	result.lib_hdl = lib_hdl;
 	result.abi_type = parsed_metadata.abi_type;
+	result.install_info->version = parsed_metadata.extension_version;
+	result.install_info->mode = install_mode;
 
 	if (!direct_load) {
-		auto info_file_name = filename + ".info";
-
-		result.install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_name, lowercase_extension_name);
-
-		if (result.install_info->mode == ExtensionInstallMode::UNKNOWN) {
-			// The info file was missing, we just set the version, since we have it from the parsed footer
-			result.install_info->version = parsed_metadata.extension_version;
-		}
-
-		if (result.install_info->version != parsed_metadata.extension_version) {
-			throw IOException("Metadata mismatch detected when loading extension '%s'\nPlease try reinstalling the "
-			                  "extension using `FORCE INSTALL '%s'`",
-			                  filename, extension);
-		}
+		/*
+		        auto info_file_name = filename + ".info";
+
+		        result.install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_name,
+		   lowercase_extension_name);
+
+		        if (result.install_info->mode == ExtensionInstallMode::UNKNOWN) {
+		            // The info file was missing, we just set the version, since we have it from the parsed footer
+		            result.install_info->version = parsed_metadata.extension_version;
+		        }
+
+		        if (result.install_info->version != parsed_metadata.extension_version) {
+		            throw IOException("Metadata mismatch detected when loading extension '%s'\nPlease try reinstalling
+		   the " "extension using `FORCE INSTALL '%s'`", filename, extension);
+		        }
+		*/
 	} else {
 		result.install_info = make_uniq<ExtensionInstallInfo>();
 		result.install_info->mode = ExtensionInstallMode::NOT_INSTALLED;
 		result.install_info->full_path = filename;
-		result.install_info->version = parsed_metadata.extension_version;
 	}
 
 	return true;
@@ -660,7 +849,7 @@ void ExtensionHelper::LoadExternalExtensionInternal(DatabaseInstance &db, FileSy
 		return;
 	}
 
-	throw IOException("Unknown ABI type of value '%s' for extension '%s'",
+	throw IOException("Unknown ABI type of value '%d' for extension '%s'",
 	                  static_cast<uint8_t>(extension_init_result.abi_type), extension);
 #endif
 }
diff --git a/src/planner/binder/statement/bind_copy.cpp b/src/planner/binder/statement/bind_copy.cpp
index 212817acb6..a7f49de754 100644
--- a/src/planner/binder/statement/bind_copy.cpp
+++ b/src/planner/binder/statement/bind_copy.cpp
@@ -223,7 +223,9 @@ BoundStatement Binder::BindCopyTo(CopyStatement &stmt, const CopyFunction &funct
 		}
 	}
 	bool is_remote_file = FileSystem::IsRemoteFile(stmt.info->file_path);
-	if (is_remote_file) {
+	if ( is_remote_file ) {
+		use_tmp_file = false;
+	} else if( context.db->config.options.use_direct_io ) {
 		use_tmp_file = false;
 	} else {
 		auto &fs = FileSystem::GetFileSystem(context);
diff --git a/src/storage/storage_manager.cpp b/src/storage/storage_manager.cpp
index f0ce909c55..b1b8f781d1 100644
--- a/src/storage/storage_manager.cpp
+++ b/src/storage/storage_manager.cpp
@@ -235,9 +235,15 @@ void SingleFileStorageManager::LoadDatabase(QueryContext context) {
 			    row_group_size, STANDARD_VECTOR_SIZE);
 		}
 	}
-	// Check if the database file already exists.
-	// Note: a file can also exist if there was a ROLLBACK on a previous transaction creating that file.
-	if (!read_only && !fs.FileExists(path)) {
+	bool is_empty_file = true;
+	auto db_file_handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ | FileFlags::FILE_FLAGS_NULL_IF_NOT_EXISTS);
+	if (db_file_handle && db_file_handle->GetFileSize() != 0) {
+		is_empty_file = false;
+		db_file_handle.reset();
+	}
+
+	// first check if the database exists
+	if (!read_only && (!fs.FileExists(path) || (options.use_direct_io && is_empty_file))) {
 		// file does not exist and we are in read-write mode
 		// create a new file
 
